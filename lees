#!/usr/bin/env bash

set -euo pipefail

# ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° root
if [[ $EUID -ne 0 ]]; then
   echo "Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸ Ð¾Ñ‚ root: sudo bash install.sh" 
   exit 1
fi

echo "=== Ð£ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° Network Monitor (Senior Go + DevSecOps) ==="
echo "Ð­Ñ‚Ð¾ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ Suricata, Zeek, Fail2Ban, Golang Ð¸ ÑÐ°Ð¼Ð¾ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ."
echo "ÐŸÑ€Ð¾Ð´Ð¾Ð»Ð¶Ð°ÐµÐ¼? (y/n)"
read -r confirm
if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    exit 0
fi

# ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹
apt update && apt upgrade -y

# Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸
apt install -y curl git wget gnupg build-essential libpcap-dev sqlite3 nmap iptables fail2ban suricata golang-go

# Ð£ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° Zeek (Debian 12 Bookworm)
echo "deb http://download.opensuse.org/repositories/security:/zeek/Debian_12/ /" | tee /etc/apt/sources.list.d/security:zeek.list
curl -fsSL https://download.opensuse.org/repositories/security:zeek/Debian_12/Release.key | gpg --dearmor | tee /etc/apt/trusted.gpg.d/security_zeek.gpg >/dev/null

apt update
apt install -y zeek || {
    echo "Zeek Ð½Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ð»ÑÑ Ð¸Ð· Ñ€ÐµÐ¿Ð¾Ð·Ð¸Ñ‚Ð¾Ñ€Ð¸Ñ. ÐŸÑ€Ð¾Ð´Ð¾Ð»Ð¶Ð°ÐµÐ¼ Ð±ÐµÐ· Ð½ÐµÐ³Ð¾ (Ð¼Ð¾Ð¶Ð½Ð¾ Ð´Ð¾ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð²Ñ€ÑƒÑ‡Ð½ÑƒÑŽ)."
}

# ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° Zeek, ÐµÑÐ»Ð¸ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½
if command -v zeekctl >/dev/null 2>&1; then
    zeekctl install
    zeekctl deploy
    zeekctl start || true
else
    echo "zeekctl Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ â†’ Zeek Ð½Ðµ Ð·Ð°Ð¿ÑƒÑÑ‚Ð¸Ð»ÑÑ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸."
fi

# ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° Suricata (ÐµÑÐ»Ð¸ Ð½Ðµ Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½ â€” Ð·Ð°Ð¿ÑƒÑÑ‚Ð¸Ð¼ Ð¿Ð¾Ð·Ð¶Ðµ)
suricata-update || true
systemctl enable suricata --now || true

# Fail2Ban jail
cat > /etc/fail2ban/filter.d/network_monitor.conf << 'EOF'
[Definition]
failregex = Failed login from <HOST>
ignoreregex =
EOF

cat > /etc/fail2ban/jail.d/network_monitor.local << 'EOF'
[network_monitor]
enabled   = true
logpath   = /var/log/network_monitor_fail2ban.log
maxretry  = 5
bantime   = 3600
findtime  = 600
EOF

systemctl restart fail2ban

# Ð”Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ñ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð°
INSTALL_DIR="/opt/network-monitor"
mkdir -p "$INSTALL_DIR"
cd "$INSTALL_DIR"

# Ð’Ð²Ð¾Ð´ ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¸
read -p "Telegram Bot Token: " TELEGRAM_TOKEN
read -p "Ð¢Ð²Ð¾Ð¹ Telegram Chat ID (Ñ‡Ð¸ÑÐ»Ð¾): " ALLOWED_CHAT_ID
read -p "Ð¡ÐµÑ‚ÐµÐ²Ð¾Ð¹ Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ (eth0/enp1s0 Ð¸ Ñ‚.Ð´.): " NETWORK_IFACE
NETWORK_IFACE=${NETWORK_IFACE:-eth0}

cat > .env << EOF
TELEGRAM_TOKEN=$TELEGRAM_TOKEN
ALLOWED_CHAT_ID=$ALLOWED_CHAT_ID
NETWORK_IFACE=$NETWORK_IFACE
EOF

chmod 600 .env

# main.go (Ð¾Ð±Ð½Ð¾Ð²Ð»Ñ‘Ð½Ð½Ñ‹Ð¹, Ñ godotenv Ð¸ Ð±ÐµÐ· Ñ…Ð°Ñ€Ð´ÐºÐ¾Ð´Ð°)
cat > main.go << 'EOF'
// Ð—Ð´ÐµÑÑŒ Ð²ÐµÑÑŒ ÐºÐ¾Ð´ Ð¸Ð· Ð¿Ñ€ÐµÐ´Ñ‹Ð´ÑƒÑ‰ÐµÐ³Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ, Ð½Ð¾ Ñ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸ÑÐ¼Ð¸:
// - import "github.com/joho/godotenv"
// - Ð¼ÐµÑ‚Ð¾Ð´ LoadConfig() Ð² App
// - Ð² main: app.LoadConfig() â†’ networkIface = app.networkIface
// - bot = tgbotapi.NewBotAPI(app.telegramToken)
// - allowedChatID = app.allowedChatID

package main

import (
 "context"
 "database/sql"
 "encoding/json"
 "fmt"
 "log"
 "net"
 "os"
 "os/exec"
 "os/signal"
 "path/filepath"
 "strconv"
 "strings"
 "sync"
 "syscall"
 "time"

 "github.com/fsnotify/fsnotify"
 "github.com/google/gopacket"
 "github.com/google/gopacket/layers"
 "github.com/google/gopacket/pcap"
 "github.com/google/uuid"
 _ "github.com/mattn/go-sqlite3"
 "github.com/joeguo/oui"
 tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
 "github.com/joho/godotenv"
 "gopkg.in/tail.v1"
)

const (
 dbFile         = "network_monitor.db"
 eveFile        = "/var/log/suricata/eve.json"
 zeekDNSLog     = "/opt/zeek/logs/current/dns.log"   // !!! Ð¿Ð¾Ð´Ð¿Ñ€Ð°Ð²ÑŒ ÐµÑÐ»Ð¸ Ð¿ÑƒÑ‚ÑŒ Ð´Ñ€ÑƒÐ³Ð¾Ð¹
 zeekHTTPLog    = "/opt/zeek/logs/current/http.log"
 snapshotLength = 1600
 promiscuous    = true
 timeout        = 30 * time.Second
 fail2banLog    = "/var/log/network_monitor_fail2ban.log"
)

type Device struct {
 IP           net.IP
 MAC          net.HardwareAddr
 Manufacturer string
 LastSeen     time.Time
 TrafficIn    uint64
 TrafficOut   uint64
 Bandwidth    uint64
}

// ... (Ð²ÑÐµ Ð¾ÑÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ðµ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ñ‹ Ð±ÐµÐ· Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹)

type App struct {
 ctx           context.Context
 cancel        context.CancelFunc
 wg            sync.WaitGroup
 devices       sync.Map
 alertsChan    chan Alert
 newDeviceChan chan Device
 db            *sql.DB
 bot           *tgbotapi.BotAPI
 knownMACs     sync.Map
 fail2banLogger *log.Logger

 telegramToken string
 allowedChatID int64
 networkIface  string
}
func (app *App) LoadConfig() error {
 if err := godotenv.Load(); err != nil {
  return err
 }
 app.telegramToken = os.Getenv("TELEGRAM_TOKEN")
 chatIDStr := os.Getenv("ALLOWED_CHAT_ID")
 var err error
 app.allowedChatID, err = strconv.ParseInt(chatIDStr, 10, 64)
 if err != nil {
  return fmt.Errorf("invalid ALLOWED_CHAT_ID: %v", err)
 }
 app.networkIface = os.Getenv("NETWORK_IFACE")
 if app.telegramToken == ""  app.allowedChatID == 0  app.networkIface == "" {
  return fmt.Errorf("missing required env variables")
 }
 return nil
}

// ... (Ð²ÑÐµ Ð¾ÑÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð¼ÐµÑ‚Ð¾Ð´Ñ‹: InitDB, TailEveLog, IntegrateZeek, ARPScan Ð¸ Ñ‚.Ð´. â€” ÑÐºÐ¾Ð¿Ð¸Ñ€ÑƒÐ¹ Ð¸Ð· Ð¿Ñ€ÐµÐ´Ñ‹Ð´ÑƒÑ‰ÐµÐ³Ð¾ Ð¿Ð¾Ð»Ð½Ð¾Ð³Ð¾ ÐºÐ¾Ð´Ð°)

// Ð’ main:
func main() {
 if os.Getuid() != 0 {
  log.Fatal("Must run as root")
 }

 app := &App{
  alertsChan:    make(chan Alert, 100),
  newDeviceChan: make(chan Device, 100),
 }

 if err := app.LoadConfig(); err != nil {
  log.Fatal("Config error:", err)
 }

 networkIface = app.networkIface  // Ð³Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ð°Ñ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð°Ñ Ð¸Ð»Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ app.networkIface Ð²ÐµÐ·Ð´Ðµ

 if err := app.InitDB(); err != nil {
  log.Fatal(err)
 }
 defer app.db.Close()

 if err := app.InitFail2banLogger(); err != nil {
  log.Fatal(err)
 }

 bot, err := tgbotapi.NewBotAPI(app.telegramToken)
 if err != nil {
  log.Fatal(err)
 }
 app.bot = bot

 if err := app.StartServices(); err != nil {
  log.Println("Services start warning:", err)
 }

 app.NotifyTelegram("Network Monitor ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½! ðŸŽ‰")

 // ... (Ð¾ÑÑ‚Ð°Ð»ÑŒÐ½Ð¾Ð¹ main: wg.Add(...), go routines, signal handling)
}
EOF

# Ð£ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° Go Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚ÐµÐ¹
go mod init network-monitor || true
go get github.com/google/gopacket
go get github.com/fsnotify/fsnotify
go get gopkg.in/tail.v1
go get github.com/go-telegram-bot-api/telegram-bot-api/v5
go get github.com/joho/godotenv
go get github.com/joeguo/oui
go get github.com/mattn/go-sqlite3
go mod tidy

# Ð¡Ð±Ð¾Ñ€ÐºÐ°
go build -o network-monitor main.go

# systemd ÑÐµÑ€Ð²Ð¸Ñ
cat > /etc/systemd/system/network-monitor.service << EOF
[Unit]
Description=Home Network Monitor (Suricata + Zeek + Telegram)
After=network.target

[Service]
Type=simple
ExecStart=$INSTALL_DIR/network-monitor
WorkingDirectory=$INSTALL_DIR
Restart=always
RestartSec=10
User=root
EnvironmentFile=$INSTALL_DIR/.env

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable network-monitor
systemctl restart network-monitor

echo "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!"
echo "ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒ:"
echo "  systemctl status network-monitor"
echo "  journalctl -u network-monitor -n 50 -f"
echo "  tail -f /var/log/suricata/eve.json"
echo "  tail -f /opt/zeek/logs/current/dns.log   # ÐµÑÐ»Ð¸ Zeek Ð·Ð°Ð¿ÑƒÑÑ‚Ð¸Ð»ÑÑ"
echo ""
echo "Ð•ÑÐ»Ð¸ Zeek Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ â€” Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑŒ /opt/zeek Ð¸Ð»Ð¸ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð¸ Ð²Ñ€ÑƒÑ‡Ð½ÑƒÑŽ."
echo "Ð£Ð´Ð°Ñ‡Ð¸! Ð•ÑÐ»Ð¸ ÑƒÐ¿Ð°Ð´Ñ‘Ñ‚ â€” ÐºÐ¸Ð´Ð°Ð¹ Ð»Ð¾Ð³Ð¸."
